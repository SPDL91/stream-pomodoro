<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>타임테이블 (AEST) - URL Config</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/tone"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* --- MODIFIED: Removed outer padding --- */
        body {
            font-family: 'Inter', sans-serif;
            color: #1a202c; /* Dark gray text */
            padding: 0; /* Removed body padding */
            font-size: 0.9rem; /* Base font size */
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.5); /* Subtle text shadow for readability */
            /* Background color will be set by JavaScript based on config */
        }

        /* --- MODIFIED: Centered and constrained the container --- */
        #schedule-container {
            width: 100%; /* Takes full width available */
            display: flex; /* Enable flexbox layout */
            flex-direction: column; /* Stack items vertically */
            align-items: center; /* Center items horizontally */
            /* No padding needed here, handled by item margins/body */
        }

        /* --- MODIFIED: Fixed maximum box width and reduced padding/margin --- */
        .schedule-item {
            border-radius: 0.375rem; /* Rounded corners */
            padding: 0.3rem 0.5rem; /* Reduced padding for compactness */
            margin: 0.25rem 0; /* Vertical margin, centered horizontally by container */
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; /* Smooth transitions */
            background-color: rgba(255, 255, 255, 0.9); /* Semi-transparent white background */
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Subtle shadow */
            display: flex; /* Use flexbox for internal layout (time/activity) */
            align-items: center; /* Vertically align content */
            gap: 0.5rem; /* Space between time and activity columns */
            max-width: 360px; /* Maximum width constraint */
            width: 100%; /* Allow shrinking below max-width */
        }

        /* Styling for the current activity */
        .schedule-item.current {
            background-color: rgba(224, 242, 254, 0.95); /* Light blue background */
            border-left: 4px solid #38bdf8; /* Blue left border highlight */
            box-shadow: 0 2px 5px rgba(0,0,0,0.15); /* Slightly stronger shadow */
        }

        /* Styling for past activities */
        .schedule-item.past {
            opacity: 0.7; /* Fade out past items */
             background-color: rgba(248, 250, 252, 0.85); /* Slightly off-white */
        }
        .schedule-item.past .activity-ko,
        .schedule-item.past .activity-en {
            text-decoration: line-through; /* Strike through text */
            color: #94a3b8; /* Gray out text */
        }

        /* Checkmark for past items */
        .checkmark {
            color: #22c55e; /* Green checkmark */
            font-weight: bold;
            margin-right: 0.25rem;
            display: inline-block; /* Keep inline */
        }

        /* --- MODIFIED: Eliminated dead space in the time column --- */
        .time-stacked-col {
            flex: 0 0 80px; /* Fixed width of 80px, prevents growing/shrinking */
            text-align: center; /* Center time text */
            font-size: 0.8rem; /* Smaller font size for time */
            color: #4a5568; /* Medium gray text */
            line-height: 1.2; /* Adjust line spacing */
        }
        .time-stacked-col span { display: block; } /* Stack time zones */
        .time-stacked-col .timezone-label { font-size: 0.7rem; color: #718096; } /* Smaller timezone label */

        /* --- MODIFIED: Allowed the activity column to fill remaining space --- */
        .activity-details-col {
             flex: 1; /* Takes up remaining space in the flex container */
             text-align: center; /* Center the text within this column */
             /* No flex-basis needed when using flex: 1 */
        }

        /* Korean activity text */
        .activity-ko {
            font-weight: 500; /* Medium font weight */
            font-size: 0.9rem; /* Base font size */
            display: block; /* Stack above English text */
            margin-bottom: 0.1rem; /* Small space below */
            color: #1e293b; /* Darker gray text */
        }

        /* English activity text */
        .activity-en {
            font-size: 0.8rem; /* Smaller font size */
            color: #64748b; /* Lighter gray text */
            display: block; /* Ensure it's on its own line */
        }
    </style>
</head>
<body class="antialiased">
    <div id="schedule-container">
        <div class="text-center text-gray-500 p-4">로드 중...</div>
    </div>

    <script>
        // --- Schedule Data (Example - Remains unchanged) ---
        const scheduleData = [
            // (Your existing schedule data goes here...)
            { aest: '00:00-00:50', kst: '23:00-23:50', ko: '집중 (50분)', en: 'Focus (50m)', startMinutesAEST: 0, endMinutesAEST: 50 }, { aest: '00:50-01:00', kst: '23:50-00:00', ko: '휴식 (10분)', en: 'Break (10m)', startMinutesAEST: 50, endMinutesAEST: 60 }, { aest: '01:00-01:50', kst: '00:00-00:50', ko: '집중 (50분)', en: 'Focus (50m)', startMinutesAEST: 60, endMinutesAEST: 110 }, { aest: '01:50-02:00', kst: '00:50-01:00', ko: '휴식 (10분)', en: 'Break (10m)', startMinutesAEST: 110, endMinutesAEST: 120 }, { aest: '02:00-02:50', kst: '01:00-01:50', ko: '집중 (50분)', en: 'Focus (50m)', startMinutesAEST: 120, endMinutesAEST: 170 }, { aest: '02:50-03:00', kst: '01:50-02:00', ko: '휴식 (10분)', en: 'Break (10m)', startMinutesAEST: 170, endMinutesAEST: 180 }, { aest: '03:00-03:50', kst: '02:00-02:50', ko: '집중 (50분)', en: 'Focus (50m)', startMinutesAEST: 180, endMinutesAEST: 230 }, { aest: '03:50-04:00', kst: '02:50-03:00', ko: '휴식 (10분)', en: 'Break (10m)', startMinutesAEST: 230, endMinutesAEST: 240 }, { aest: '04:00-05:00', kst: '03:00-04:00', ko: '긴 휴식 (60분)', en: 'Long Break (60m)', startMinutesAEST: 240, endMinutesAEST: 300 }, { aest: '05:00-05:50', kst: '04:00-04:50', ko: '집중 (50분)', en: 'Focus (50m)', startMinutesAEST: 300, endMinutesAEST: 350 }, { aest: '05:50-06:00', kst: '04:50-05:00', ko: '휴식 (10분)', en: 'Break (10m)', startMinutesAEST: 350, endMinutesAEST: 360 }, // ... rest of your data
        ];
        const scheduleLength = scheduleData.length;

        // --- DOM Elements ---
        const scheduleContainer = document.getElementById('schedule-container');

        // --- State Variables (Unchanged) ---
        let currentActivityIndex = -1;
        let synth = null;
        let isMuted = false;
        let currentVolume = -10;
        let soundInitialized = false;
        let audioContextResumed = false;

        // --- Configuration (Defaults - Unchanged) ---
        let config = { linesBefore: 3, linesAfter: 3, volume: -10, muted: false, bgColor: 'f0f4f8', bgAlpha: 1.0 };

        // --- Helper Functions (getUrlParams, hexToRgba - Unchanged) ---
        function getUrlParams() { const params = new URLSearchParams(window.location.search); const urlConfig = {}; const linesBeforeParam = params.get('linesBefore'); if (linesBeforeParam !== null) { const val = parseInt(linesBeforeParam, 10); if (!isNaN(val) && val >= 0) urlConfig.linesBefore = val; } const linesAfterParam = params.get('linesAfter'); if (linesAfterParam !== null) { const val = parseInt(linesAfterParam, 10); if (!isNaN(val) && val >= 0) urlConfig.linesAfter = val; } const volumeParam = params.get('volume'); if (volumeParam !== null) { const val = parseFloat(volumeParam); if (!isNaN(val)) urlConfig.volume = val; } const mutedParam = params.get('muted'); if (mutedParam !== null) { urlConfig.muted = mutedParam.toLowerCase() === 'true'; } const bgColorParam = params.get('bgColor'); if (bgColorParam !== null && /^[0-9a-fA-F]{6}$/.test(bgColorParam)) { urlConfig.bgColor = bgColorParam; } else if (bgColorParam !== null && /^[0-9a-fA-F]{3}$/.test(bgColorParam)) { urlConfig.bgColor = bgColorParam.split('').map(c => c+c).join(''); } const bgAlphaParam = params.get('bgAlpha'); if (bgAlphaParam !== null) { const val = parseFloat(bgAlphaParam); if (!isNaN(val) && val >= 0 && val <= 1) { urlConfig.bgAlpha = val; } } return urlConfig; }
        function hexToRgba(hex, alpha) { hex = hex.replace(/^#/, ''); if (hex.length === 3) { hex = hex.split('').map(c => c + c).join(''); } if (hex.length !== 6) { console.warn(`Invalid hex color: #${hex}. Falling back.`); return `rgba(240, 244, 248, ${alpha})`; } const bigint = parseInt(hex, 16); const r = (bigint >> 16) & 255; const g = (bigint >> 8) & 255; const b = bigint & 255; alpha = Math.max(0, Math.min(1, alpha)); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }

        // --- Apply Configuration (Unchanged) ---
        function applyConfiguration() { const urlParams = getUrlParams(); config = { ...config, ...urlParams }; console.log("Applied Configuration:", config); document.body.style.backgroundColor = hexToRgba(config.bgColor, config.bgAlpha); isMuted = config.muted; currentVolume = config.volume; if (soundInitialized && synth && synth.volume) { synth.volume.value = isMuted ? -Infinity : currentVolume; console.log("Initial sound volume set from config:", synth.volume.value); } }

        // --- Sound Functions (Unchanged) ---
        function initializeSound() { if (soundInitialized && synth) { if (synth.volume) synth.volume.value = isMuted ? -Infinity : currentVolume; return true; } if (typeof Tone === 'undefined' || !Tone.Synth) { console.error("Tone.js library not loaded correctly."); return false; } if (Tone.context.state !== 'running') { if (audioContextResumed) { Tone.start().catch(err => console.warn("Could not resume AudioContext even after interaction:", err)); } else { console.log("AudioContext not running. Waiting for user interaction (click/touch)."); return false; } } if (Tone.context.state !== 'running') { console.log("AudioContext still not running after attempt."); return false; } try { synth = new Tone.Synth().toDestination(); synth.volume.value = isMuted ? -Infinity : currentVolume; soundInitialized = true; console.log("Sound initialized. Volume:", isMuted ? "Muted" : `${currentVolume} dB`); return true; } catch (error) { console.error("Error creating Tone.Synth:", error); soundInitialized = false; synth = null; return false; } }
        function playNotificationSound(isUnmuteSound = false) { if (!soundInitialized || !synth) { if (!isUnmuteSound) console.log("Sound not initialized. Attempting now..."); if (!initializeSound()) { if (!isUnmuteSound) console.log("Sound initialization failed. Cannot play sound yet."); return; } } if (isMuted) { if (!isUnmuteSound) console.log("Sound muted, skipping playback."); return; } if (Tone.context.state !== 'running') { if (!isUnmuteSound) console.log(`AudioContext not running (${Tone.context.state}). Cannot play sound.`); if (audioContextResumed) { Tone.start().catch(err => console.warn("Could not resume AudioContext:", err)); } return; } try { const note = isUnmuteSound ? "E5" : "C5"; synth.triggerAttackRelease(note, "8n", Tone.now() + 0.05); if (!isUnmuteSound) console.log("Played notification sound."); else console.log("Played unmute confirmation sound."); } catch (error) { console.error("Error playing sound:", error); } }
        function getCurrentAESTTime() { const now = new Date(); try { const timeString = now.toLocaleTimeString('en-AU', { timeZone: 'Australia/Sydney', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false }); const [hours, minutes, seconds] = timeString.split(':').map(Number); return { hours, minutes, seconds }; } catch (error) { console.error("Error getting AEST time using Intl:", error); const utcHours = now.getUTCHours(); const month = now.getUTCMonth(); const isAEDT = (month > 8 || month < 3); const offset = isAEDT ? 11 : 10; const aestHours = (utcHours + offset) % 24; const minutes = now.getUTCMinutes(); const seconds = now.getUTCSeconds(); console.warn(`Falling back to manual UTC+${offset} calculation.`); return { hours: aestHours, minutes, seconds }; } }

        // --- Create Schedule Item Element (Unchanged, structure relies on new CSS) ---
        function createScheduleElement(itemData) {
            const { item, index, status } = itemData;
            const itemDiv = document.createElement('div');
            itemDiv.classList.add('schedule-item'); // Uses the updated .schedule-item style
            itemDiv.id = `schedule-item-${index}`;
            let checkmark = '';
            switch (status) {
                case 'past': itemDiv.classList.add('past'); checkmark = '<span class="checkmark">✔</span>'; break;
                case 'current': itemDiv.classList.add('current'); break;
                case 'future': default: itemDiv.classList.add('future'); break;
            }
            // Inner HTML structure remains the same, but layout is controlled by the updated CSS rules
            itemDiv.innerHTML = `
                <div class="time-stacked-col"> <span>${item.aest} <span class="timezone-label">(AEST)</span></span>
                    <span>${item.kst} <span class="timezone-label">(KST)</span></span>
                </div>
                <div class="activity-details-col"> <span class="activity-ko">${checkmark}${item.ko}</span>
                    <span class="activity-en">${item.en}</span>
                </div>`;
            return itemDiv;
        }

        // --- Update Schedule Display (Unchanged logic) ---
        function updateSchedule() {
             if (!scheduleContainer || scheduleLength === 0) { console.error("Schedule container not found or schedule data empty."); scheduleContainer.innerHTML = '<div class="text-center text-gray-500 p-4">Error loading schedule.</div>'; return; }
            const { hours, minutes } = getCurrentAESTTime();
            const currentTotalMinutes = hours * 60 + minutes;
            let activityChanged = false;
            let newCurrentIndex = -1;
            for (let i = 0; i < scheduleLength; i++) { const item = scheduleData[i]; const start = item.startMinutesAEST; const end = item.endMinutesAEST === 0 ? 1440 : item.endMinutesAEST; if (start < end) { if (currentTotalMinutes >= start && currentTotalMinutes < end) { newCurrentIndex = i; break; } } else { if (currentTotalMinutes >= start || currentTotalMinutes < end) { newCurrentIndex = i; break; } } } if (newCurrentIndex === -1 && currentTotalMinutes === 0 && scheduleData[0]?.startMinutesAEST === 0) { newCurrentIndex = 0; }
            if (newCurrentIndex !== currentActivityIndex) { activityChanged = true; if (currentActivityIndex !== -1) { console.log(`Activity changed from index ${currentActivityIndex} to ${newCurrentIndex}`); playNotificationSound(); } else { console.log(`Initial activity index set to ${newCurrentIndex}`); } currentActivityIndex = newCurrentIndex; }
            const currentLinesBefore = config.linesBefore; const currentLinesAfter = config.linesAfter;
            const itemsToDisplay = []; const displayedIndices = new Set();
            if (currentActivityIndex !== -1) {
                for (let i = currentLinesBefore; i >= 1; i--) { const index = (currentActivityIndex - i + scheduleLength) % scheduleLength; if (!displayedIndices.has(index)) { itemsToDisplay.push({ item: scheduleData[index], index: index, status: 'past' }); displayedIndices.add(index); } }
                 if (!displayedIndices.has(currentActivityIndex)) { itemsToDisplay.push({ item: scheduleData[currentActivityIndex], index: currentActivityIndex, status: 'current' }); displayedIndices.add(currentActivityIndex); }
                for (let i = 1; i <= currentLinesAfter; i++) { const index = (currentActivityIndex + i) % scheduleLength; if (!displayedIndices.has(index)) { itemsToDisplay.push({ item: scheduleData[index], index: index, status: 'future' }); displayedIndices.add(index); } }
                 console.debug(`UpdateSchedule - CurrentIdx: ${currentActivityIndex}, Before: ${currentLinesBefore}, After: ${currentLinesAfter}, Items:`, itemsToDisplay.map(d => `(${d.index}:${d.status})`).join(', '));
            } else {
                for (let i = 0; i < Math.min(currentLinesAfter + 1, scheduleLength); i++) { if (!displayedIndices.has(i)) { itemsToDisplay.push({ item: scheduleData[i], index: i, status: 'future' }); displayedIndices.add(i); } }
                 console.debug(`UpdateSchedule - No current activity, showing first ${itemsToDisplay.length} items.`);
            }
            scheduleContainer.innerHTML = '';
            if (itemsToDisplay.length === 0 && scheduleLength > 0) { scheduleContainer.innerHTML = '<div class="text-center text-gray-500 p-4">표시할 항목이 없습니다.</div>'; } else { itemsToDisplay.forEach(itemData => { scheduleContainer.appendChild(createScheduleElement(itemData)); }); }
             if (currentActivityIndex === -1 && itemsToDisplay.length > 0) { const infoDiv = document.createElement('div'); infoDiv.className = 'text-center text-orange-600 text-xs p-2'; infoDiv.textContent = '현재 진행 중인 활동이 없습니다.'; scheduleContainer.insertAdjacentElement('afterbegin', infoDiv); }
        }

        // --- Initial Setup and Update Loop (Unchanged) ---
        applyConfiguration();
        if (scheduleContainer) { updateSchedule(); } else { console.error("Schedule container not found for initial update."); }
        const updateInterval = setInterval(updateSchedule, 5000); // Update every 5 seconds

        // --- Audio Context Handling (Unchanged) ---
        function handleUserInteraction() { if (typeof Tone === 'undefined') return; if (Tone.context.state !== 'running') { console.log("User interaction detected, attempting to start/resume AudioContext..."); Tone.start().then(() => { console.log("AudioContext started/resumed successfully via user interaction."); audioContextResumed = true; if (!soundInitialized) { initializeSound(); } if (synth && synth.volume) { synth.volume.value = isMuted ? -Infinity : currentVolume; } updateSchedule(); }).catch(err => { console.error("Error starting/resuming AudioContext on interaction:", err); }).finally(() => { document.body.removeEventListener('click', handleUserInteraction); document.body.removeEventListener('touchstart', handleUserInteraction); }); } else if (!soundInitialized) { console.log("AudioContext running, attempting to initialize sound now."); initializeSound(); document.body.removeEventListener('click', handleUserInteraction); document.body.removeEventListener('touchstart', handleUserInteraction); } else { document.body.removeEventListener('click', handleUserInteraction); document.body.removeEventListener('touchstart', handleUserInteraction); } }
        document.body.addEventListener('click', handleUserInteraction);
        document.body.addEventListener('touchstart', handleUserInteraction);
        window.addEventListener('load', () => { console.log("Window loaded."); initializeSound(); });

    </script>

</body>
</html>
